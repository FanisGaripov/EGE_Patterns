# Шаблон для 16 задачи ЕГЭ по информатике


'''Об этой задаче:
Грубо говоря, здесь мы занимаемся переписыванием алгоритма,
данного в условии. Ничего сложного нет. Делаем сначала это. Дальше есть 4 пути развития
1) Нам хватит стека, числа маленькие и ошибки не будет
2) Стека не хватило, используем setrecursionlimit
3) Стека не хватило, используем lru_cache
4) Используем динамическое программирование(самое сложное, но одновременно эффективное решение)

По поводу второго способа, крайне не рекомендую его использовать, т.к на ЕГЭ ноуты с 4гб оперативной памяти
и увеличение лимита напрямую может повлиять на то, будете ли вы писать экзамен дальше. Ноутбук может просто зависнуть
и всё: -время, -деньги, -баллы. Поэтому это можно делать только на машинах, способных выдержать такое.
Советую lru_cache, т.к это удобный способ, позволяющий не переписывать все динамически
А вообще, эталонное решение - это решение через списки, т.е динамически! Оно и выглядит проще и работает быстрее.
'''

'''
Алгоритм вычисления значения функции 
F(n) и G(n), где n – целое число, задан следующими соотношениями:
F(n)=2×(G(n−3)+8);
G(n)=2×n, если n<10.
G(n)=G(n−2)+1, если n≥10.
Чему равно значение выражения F(15548)?
'''
# импортируем lru_cache из functools
from functools import lru_cache
# вставляем декоратор к любой функции, значения которой хотим кешировать

@lru_cache(maxsize=None)
def G(n):
    if n < 10:
        return 2 * n
    else:
        return G(n - 2) + 1


def F(n):
    return 2 * (G(n - 3) + 8)

# перебираю значения функции от 0 до 16000 и сохраняю в памяти,
# чтобы быстро достать их оттуда при вызове ф-ции.
# достаточно было перебирать до 15549 :)
for i in range(16000):
    G(i)

print(F(15548)) # ответ

'''Динамическое решение'''
g = [] # список g
# переписываем в цикл те же условия, что в задаче
for n in range(15548):
    if n < 10:
        g.append(2 * n)
    else:
        g.append(g[n - 2] + 1)

# функцию оставил, т.к она выполняется всего 1 раз(просто достает элемент по индексу)
def F(n):
    return 2 * (g[n - 3] + 8)

print(F(15548)) # ответ(такой же как в 1ом шаблоне)