# Шаблон для 27 задачи ЕГЭ по информатике


'''27 задача - задача на класстеризацию
Считается одной из самых сложных, сложнее только 26 задача.
Шаблон практически всегда 1. Однако есть два способа разделения кластеров:
1) Открываем libreoffice, строим диаграмму и видим на каких x, y кластеры
разделены
2) Алгоритм dbscan: берется случайная точка и на определенном радиусе(eps) от нее
ищутся другие точки. Если точка находится, то процесс повторяется и с ней,
ищется еще точка, которая еще не была в кластере. И так до тех пор, пока точки не кончатся.
Если точки больше не находятся, то кластер объявляется завершенным и начинается сбор
нового кластера. Алгоритм менее эффективен чем 1 способ, но сильно экономит время на экзамене.
Тем более, не всегда можно разделить кластеры по определенным x, y. Там на помощь приходит только dbscan.
'''


'''
Фрагмент звёздного неба спроецирован на плоскость с декартовой системой координат. 
Учёный решил провести кластеризацию полученных точек, являющихся изображениями звёзд, 
то есть разбить их множество на N непересекающихся непустых подмножеств (кластеров), 
таких что точки каждого подмножества лежат внутри прямоугольника со сторонами длиной H и W, 
причём эти прямоугольники между собой не пересекаются. Стороны прямоугольников не обязательно параллельны координатным осям.
Гарантируется, что такое разбиение существует и единственно для заданных размеров прямоугольников.
Будем называть центром кластера точку этого кластера, сумма расстояний от которой до всех остальных точек кластера минимальна. 
Для каждого кластера гарантируется единственность его центра. Расстояние между двумя точками на плоскости ...
В файле A хранятся данные о звёздах двух кластеров, где H=6, W=4,5 для каждого кластера. 
В каждой строке записана информация о расположении на карте одной звезды: сначала координата x, затем координата y. 
Значения даны в условных единицах. Известно, что количество звёзд не превышает 1000.
В файле B хранятся данные о звёздах трёх кластеров, где H=6, W=5 для каждого кластера. 
Известно, что количество звёзд не превышает 1000. Структура хранения информации о звездах в файле B аналогична файлу А. 
Известно, что в файле Б имеются координаты ровно трёх «лишних» точек, являющихся аномалиями, 
возникшими в результате помех при передаче данных. Эти три точки не относятся ни к одному из кластеров, их учитывать не нужно.

Для файла А определите координаты центра каждого кластера, затем найдите два числа: 
Px - минимальную из абсцисс центров кластеров, и 
Py - минимальную из ординат центров кластеров. 

Для файла Б найдите два числа: 
Q1 - расстояние между центрами кластеров с минимальным и максимальным количеством точек, и 
Q2 - максимальное расстояние от центра кластера до точки этого же кластера среди всех кластеров.

Гарантируется, что во всех кластерах количество точек различно.
В ответе запишите четыре числа: в первой строке - сначала абсолютную величину целой части произведения 
Px × 10000, затем абсолютную величину целой части произведения 
Py × 10 000; во второй строке - сначала целую часть произведения 
Q1 × 10 000, затем целую часть произведения 
Q2 × 10 000.

Возможные данные одного из файлов иллюстрированы графиком. 
Внимание! График приведён в иллюстративных целях для произвольных значений, не имеющих отношения к заданию.
Для выполнения задания используйте данные из прилагаемого файла. 
'''

from math import dist # импортируем формулу из задания(импорт необязателен, можно написать и свою ф-цию)
'''Внимание! dist появился в версии python 3.8, если на компьютере установлена версия <= 3.7, придётся писать свою ф-цию:
from math import sqrt

def dist(p1, p2):
    x1, y1 = p1
    x2, y2 = p2
    return sqrt((x2-x1)**2 + (y2-y1)**2)
    

Также в авторских задачах нередко встречается и Манхэттенское расстояние |x1 - x2| + |y1 - y2|
def manhattan(p1, p2):
    x1, y1 = p1
    x2, y2 = p2
    return abs(x1 - x2) + abs(y1 - y2)
Тогда заменяем все dist на нашу ф-цию manhattan(или Ваше название)
'''
from turtle import * # для визуализации точек

f = open('27_A_23766.txt') # открыли файл
'''Заменяем запятые на точки, т.к python не принимает запятые в числах
разделяем числа на x, y и приводим к типу float(нецелое число)'''
points = [list(map(float, r.replace(',', '.').split())) for r in f]
clusters = [] # создали список кластеров
eps = 2 # радиус поиска точек. Подгоняем после просмотра визуализации
# Алгоритм DBSCAN - неизменный
while points:
    clusters.append([points[0]])
    del points[0]
    for p1 in clusters[-1]:
        for p2 in points[:]:
            if dist(p1, p2) < eps:
                clusters[-1].append(p2)
                points.remove(p2)
'''Здесь мы взяли случайную точку, удалили ее из списка, т.к использовали.
Дальше искали точки, которые находятся рядом(ближе eps) с исходной и удаляли их тоже.
Так мы сформировали 2 кластера'''

# функция нахождения центроида - неизменна
def centroid(cluster):
    c = []
    for x1, y1 in cluster:
        c += [[sum(dist([x1, y1], [x2, y2]) for x2, y2 in cluster), (x1, y1)]]
    return min(c)[1]
'''Коротко, мы нашли точку, расстояние от до которой от других меньше всего. Ф-ция возвращает ее координаты'''

# визуализация - неизменна
def visual(clusters):
    tracer(0); screensize(2000, 2000); penup();
    # пропуск анимации, высокое разрешение, перо поднято, определены цвета и масштаб
    colors = ['red', 'green', 'blue']
    k = 30
    # перебираем каждую точку и ставим точку того цвета, который принадлежит кластеру
    for i in range(len(clusters)):
        for x, y in clusters[i]:
            goto(x * k, y * k)
            dot(3, colors[i])
    update()
    done()


# visual(clusters)
'''Предыдущую строчку можно раскомментировать и увидеть все точки кластеров.
Используем ее для подгонки eps и для того, чтобы не открывать лишних программ, решая быстрее других :)
'''
centers = []
for i in range(len(clusters)):
    centers.append(centroid(clusters[i])) # нашел центры, записал в список
p_x = min([x for x, y in centers]) # минимальная абцисса(координата x) из центров
p_y = min([y for x, y in centers]) # минимальная ордината(координата y) из центров
print(int(p_x * 10000), int(p_y * 10000)) # выводим умноженные на 10000 и только целую часть.
# Если число отрицательное можно обернуть в abs и получить абсолютное значение(модуль).