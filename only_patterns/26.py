# Шаблон для 26 задачи ЕГЭ по информатике


'''Отдел маркетинга сети магазинов составляет рейтинг продуктов по информации об их сроках хранения с момента изготовления и после
вскрытия упаковки. Для каждого продукта известен срок его хранения с момента изготовления и срок годности к употреблению после вскрытия упаковки. 
Продукты пронумерованы начиная с единицы.
В рейтинговом списке маркетологи располагают продукты по следующему алгоритму:
– все 2N чисел, обозначающих срок хранения и срок годности к употреблению для N продуктов, упорядочивают по возрастанию;
– если минимальное число в этом упорядоченном списке – срок хранения, то продукт в рейтинге занимает первое свободное место от
его начала;
– если минимальное число – срок годности к употреблению, то продукт занимает первое свободное место от конца рейтинга;
– если число обозначает срок хранения или срок годности к употреблению уже рассмотренного продукта, то его не принимают во внимание.
Этот алгоритм применяется последовательно для размещения всех N продуктов.
Определите номер последнего продукта, для которого будет определено его место в рейтинге, и количество продуктов, которые займут в рейтинге более низкие места.
Входные данные
В первой строке входного файла находится натуральное число N (N ≤ 1000) – количество продуктов. Следующие N строк содержат пары
чисел, обозначающих соответственно срок хранения продукта с момента изготовления и срок годности к употреблению после вскрытия упаковки (все числа натуральные, различные).
Запишите в ответе два натуральных числа: сначала номер последнего продукта, для которого будет определено его место в рейтинге, 
затем – количество продуктов, которые займут в рейтинге более низкие места. '''


f = open('26_23765.txt')
N = int(f.readline())
s = []
for _ in range(N):
    s.append(list(map(int, f.readline().split())))
spisok = []
s_copy = s[:]
for l, r in s:
    spisok.append(l)
    spisok.append(r)
spisok.sort()
rating_start = []
rating_end = []
for i in spisok:
    for j in s:
        if i in j:
            if i == j[0]:
                rating_start.append([j[0], j[1]])
                spisok.remove(j[1])
            else:
                rating_end.append([j[0], j[1]])
                spisok.remove(j[0])
print(s_copy.index(rating_end[-1]) + 1)
print(len(rating_end) - 1)